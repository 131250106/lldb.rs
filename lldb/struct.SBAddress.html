<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `SBAddress` struct in crate `lldb`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, SBAddress">

    <title>lldb::SBAddress - Rust</title>

    <link rel="stylesheet" type="text/css" href="../rustdoc.css">
    <link rel="stylesheet" type="text/css" href="../main.css">
    

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <nav class="sidebar">
        
        <p class='location'><a href='index.html'>lldb</a></p><script>window.sidebarCurrent = {name: 'SBAddress', ty: 'struct', relpath: ''};</script><script defer src="sidebar-items.js"></script>
    </nav>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press ‘S’ to search, ‘?’ for more options…"
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content struct">
<h1 class='fqn'><span class='in-band'>Struct <a href='index.html'>lldb</a>::<wbr><a class='struct' href=''>SBAddress</a></span><span class='out-of-band'><span id='render-detail'>
                   <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">
                       [<span class='inner'>&#x2212;</span>]
                   </a>
               </span><a id='src-26' class='srclink' href='../src/lldb/src/address.rs.html#50-53' title='goto source code'>[src]</a></span></h1>
<pre class='rust struct'>pub struct SBAddress {
    pub raw: <a class='type' href='../lldb_sys/lldb_sys/type.SBAddressRef.html' title='lldb_sys::lldb_sys::SBAddressRef'>SBAddressRef</a>,
}</pre><div class='docblock'><p>A section + offset based address class.</p>

<p>The <code>SBAddress</code> class allows addresses to be relative to a section
that can move during runtime due to images (executables, shared
libraries, bundles, frameworks) being loaded at different
addresses than the addresses found in the object file that
represents them on disk. There are currently two types of addresses
for a section:</p>

<ul>
<li>file addresses</li>
<li>load addresses</li>
</ul>

<p>File addresses represents the virtual addresses that are in the &#39;on
disk&#39; object files. These virtual addresses are converted to be
relative to unique sections scoped to the object file so that
when/if the addresses slide when the images are loaded/unloaded
in memory, we can easily track these changes without having to
update every object (compile unit ranges, line tables, function
address ranges, lexical block and inlined subroutine address
ranges, global and static variables) each time an image is loaded or
unloaded.</p>

<p>Load addresses represents the virtual addresses where each section
ends up getting loaded at runtime. Before executing a program, it
is common for all of the load addresses to be unresolved. When a
<code>DynamicLoader</code> plug-in receives notification that shared libraries
have been loaded/unloaded, the load addresses of the main executable
and any images (shared libraries) will be  resolved/unresolved. When
this happens, breakpoints that are in one of these sections can be
set/cleared.</p>
</div><h2 class='fields'>Fields</h2>
<table><tr class='stab '>
                             <td id='structfield.raw'><code>raw</code></td><td><div class='docblock'><p>The underlying raw <code>SBAddressRef</code>.</p>
</div></td></tr></table><h2 id='methods'>Methods</h2><h3 class='impl'><code>impl <a class='struct' href='../lldb/struct.SBAddress.html' title='lldb::SBAddress'>SBAddress</a></code></h3><div class='impl-items'><h4 id='method.wrap' class='method'><code>fn <a href='#method.wrap' class='fnname'>wrap</a>(raw: <a class='type' href='../lldb_sys/lldb_sys/type.SBAddressRef.html' title='lldb_sys::lldb_sys::SBAddressRef'>SBAddressRef</a>) -&gt; <a class='struct' href='../lldb/struct.SBAddress.html' title='lldb::SBAddress'>SBAddress</a></code></h4>
<div class='docblock'><p>Construct a new <code>SBAddress</code>.</p>
</div><h4 id='method.maybe_wrap' class='method'><code>fn <a href='#method.maybe_wrap' class='fnname'>maybe_wrap</a>(raw: <a class='type' href='../lldb_sys/lldb_sys/type.SBAddressRef.html' title='lldb_sys::lldb_sys::SBAddressRef'>SBAddressRef</a>) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../lldb/struct.SBAddress.html' title='lldb::SBAddress'>SBAddress</a>&gt;</code></h4>
<div class='docblock'><p>Construct a new <code>Some(SBAddress)</code> or <code>None</code>.</p>
</div><h4 id='method.is_valid' class='method'><code>fn <a href='#method.is_valid' class='fnname'>is_valid</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.bool.html'>bool</a></code></h4>
<div class='docblock'><p>Check whether or not this is a valid <code>SBAddress</code> value.</p>
</div><h4 id='method.file_address' class='method'><code>fn <a href='#method.file_address' class='fnname'>file_address</a>(&amp;self) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a></code></h4>
<div class='docblock'><p>The address that represents the address as it is found in the
object file that defines it.</p>
</div><h4 id='method.load_address' class='method'><code>fn <a href='#method.load_address' class='fnname'>load_address</a>(&amp;self, target: &amp;<a class='struct' href='../lldb/struct.SBTarget.html' title='lldb::SBTarget'>SBTarget</a>) -&gt; <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u64.html'>u64</a></code></h4>
<div class='docblock'><p>The address as it has been loaded into memory by a target.</p>
</div><h4 id='method.address_class' class='method'><code>fn <a href='#method.address_class' class='fnname'>address_class</a>(&amp;self) -&gt; <a class='enum' href='../lldb/enum.AddressClass.html' title='lldb::AddressClass'>AddressClass</a></code></h4>
<div class='docblock'><p>Get the address class for this address.</p>
</div><h4 id='method.symbol_context' class='method'><code>fn <a href='#method.symbol_context' class='fnname'>symbol_context</a>(&amp;self, resolve_scope: <a class='primitive' href='https://doc.rust-lang.org/nightly/std/primitive.u32.html'>u32</a>) -&gt; <a class='struct' href='../lldb/struct.SBSymbolContext.html' title='lldb::SBSymbolContext'>SBSymbolContext</a></code></h4>
<div class='docblock'><p>Get the <code>SBSymbolContext</code> for a given address.</p>

<p>An address might refer to code or data from an existing
module, or it might refer to something on the stack or heap.
This will only return valid values if the address has been
resolved to a code or data address using
<code>SBAddress::set_load_address</code> or <code>SBTarget::resolve_load_address</code>.</p>
</div><h4 id='method.module' class='method'><code>fn <a href='#method.module' class='fnname'>module</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../lldb/struct.SBModule.html' title='lldb::SBModule'>SBModule</a>&gt;</code></h4>
<div class='docblock'><p>Get the <code>SBModule</code> for a given address.</p>

<p>An address might refer to code or data from an existing
module, or it might refer to something on the stack or heap.
This will only return valid values if the address has been
resolved to a code or data address using
<code>SBAddress::set_load_address</code> or <code>SBTarget::resolve_load_address</code>.</p>

<p>This grabs an individual object for a given address and
is less efficient if you want more than one symbol related objects.
Use one of the following when you want multiple debug symbol related
objects for an address:</p>

<ul>
<li><code>SBAddress::symbol_context</code></li>
<li><code>SBTarget::resolve_symbol_context_for_address</code></li>
</ul>

<p>One or more bits from the <code>SymbolContextItem</code> enumerations can be logically
OR&#39;ed together to more efficiently retrieve multiple symbol objects.</p>
</div><h4 id='method.compile_unit' class='method'><code>fn <a href='#method.compile_unit' class='fnname'>compile_unit</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../lldb/struct.SBCompileUnit.html' title='lldb::SBCompileUnit'>SBCompileUnit</a>&gt;</code></h4>
<div class='docblock'><p>Get the <code>SBCompileUnit</code> for a given address.</p>

<p>An address might refer to code or data from an existing
module, or it might refer to something on the stack or heap.
This will only return valid values if the address has been
resolved to a code or data address using
<code>SBAddress::set_load_address</code> or <code>SBTarget::resolve_load_address</code>.</p>

<p>This grabs an individual object for a given address and
is less efficient if you want more than one symbol related objects.
Use one of the following when you want multiple debug symbol related
objects for an address:</p>

<ul>
<li><code>SBAddress::symbol_context</code></li>
<li><code>SBTarget::resolve_symbol_context_for_address</code></li>
</ul>

<p>One or more bits from the <code>SymbolContextItem</code> enumerations can be logically
OR&#39;ed together to more efficiently retrieve multiple symbol objects.</p>
</div><h4 id='method.function' class='method'><code>fn <a href='#method.function' class='fnname'>function</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../lldb/struct.SBFunction.html' title='lldb::SBFunction'>SBFunction</a>&gt;</code></h4>
<div class='docblock'><p>Get the <code>SBFunction</code> for a given address.</p>

<p>An address might refer to code or data from an existing
module, or it might refer to something on the stack or heap.
This will only return valid values if the address has been
resolved to a code or data address using
<code>SBAddress::set_load_address</code> or <code>SBTarget::resolve_load_address</code>.</p>

<p>This grabs an individual object for a given address and
is less efficient if you want more than one symbol related objects.
Use one of the following when you want multiple debug symbol related
objects for an address:</p>

<ul>
<li><code>SBAddress::symbol_context</code></li>
<li><code>SBTarget::resolve_symbol_context_for_address</code></li>
</ul>

<p>One or more bits from the <code>SymbolContextItem</code> enumerations can be logically
OR&#39;ed together to more efficiently retrieve multiple symbol objects.</p>
</div><h4 id='method.block' class='method'><code>fn <a href='#method.block' class='fnname'>block</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../lldb/struct.SBBlock.html' title='lldb::SBBlock'>SBBlock</a>&gt;</code></h4>
<div class='docblock'><p>Get the <code>SBBlock</code> for a given address.</p>

<p>An address might refer to code or data from an existing
module, or it might refer to something on the stack or heap.
This will only return valid values if the address has been
resolved to a code or data address using
<code>SBAddress::set_load_address</code> or <code>SBTarget::resolve_load_address</code>.</p>

<p>This grabs an individual object for a given address and
is less efficient if you want more than one symbol related objects.
Use one of the following when you want multiple debug symbol related
objects for an address:</p>

<ul>
<li><code>SBAddress::symbol_context</code></li>
<li><code>SBTarget::resolve_symbol_context_for_address</code></li>
</ul>

<p>One or more bits from the <code>SymbolContextItem</code> enumerations can be logically
OR&#39;ed together to more efficiently retrieve multiple symbol objects.</p>
</div><h4 id='method.symbol' class='method'><code>fn <a href='#method.symbol' class='fnname'>symbol</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../lldb/struct.SBSymbol.html' title='lldb::SBSymbol'>SBSymbol</a>&gt;</code></h4>
<div class='docblock'><p>Get the <code>SBSymbol</code> for a given address.</p>

<p>An address might refer to code or data from an existing
module, or it might refer to something on the stack or heap.
This will only return valid values if the address has been
resolved to a code or data address using
<code>SBAddress::set_load_address</code> or <code>SBTarget::resolve_load_address</code>.</p>

<p>This grabs an individual object for a given address and
is less efficient if you want more than one symbol related objects.
Use one of the following when you want multiple debug symbol related
objects for an address:</p>

<ul>
<li><code>SBAddress::symbol_context</code></li>
<li><code>SBTarget::resolve_symbol_context_for_address</code></li>
</ul>

<p>One or more bits from the <code>SymbolContextItem</code> enumerations can be logically
OR&#39;ed together to more efficiently retrieve multiple symbol objects.</p>
</div><h4 id='method.line_entry' class='method'><code>fn <a href='#method.line_entry' class='fnname'>line_entry</a>(&amp;self) -&gt; <a class='enum' href='https://doc.rust-lang.org/nightly/core/option/enum.Option.html' title='core::option::Option'>Option</a>&lt;<a class='struct' href='../lldb/struct.SBLineEntry.html' title='lldb::SBLineEntry'>SBLineEntry</a>&gt;</code></h4>
<div class='docblock'><p>Get the <code>SBLineEntry</code> for a given address.</p>

<p>An address might refer to code or data from an existing
module, or it might refer to something on the stack or heap.
This will only return valid values if the address has been
resolved to a code or data address using
<code>SBAddress::set_load_address</code> or <code>SBTarget::resolve_load_address</code>.</p>

<p>This grabs an individual object for a given address and
is less efficient if you want more than one symbol related objects.
Use one of the following when you want multiple debug symbol related
objects for an address:</p>

<ul>
<li><code>SBAddress::symbol_context</code></li>
<li><code>SBTarget::resolve_symbol_context_for_address</code></li>
</ul>

<p>One or more bits from the <code>SymbolContextItem</code> enumerations can be logically
OR&#39;ed together to more efficiently retrieve multiple symbol objects.</p>
</div></div><h2 id='implementations'>Trait Implementations</h2><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html' title='core::fmt::Debug'>Debug</a> for <a class='struct' href='../lldb/struct.SBAddress.html' title='lldb::SBAddress'>SBAddress</a></code></h3><div class='impl-items'><h4 id='method.fmt' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt' class='fnname'>fmt</a>(&amp;self, fmt: &amp;mut <a class='struct' href='https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html' title='core::fmt::Formatter'>Formatter</a>) -&gt; <a class='type' href='https://doc.rust-lang.org/nightly/core/fmt/type.Result.html' title='core::fmt::Result'>Result</a></code></h4>
</div><h3 class='impl'><code>impl <a class='trait' href='https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html' title='core::ops::Drop'>Drop</a> for <a class='struct' href='../lldb/struct.SBAddress.html' title='lldb::SBAddress'>SBAddress</a></code></h3><div class='impl-items'><h4 id='method.drop' class='method'><code>fn <a href='https://doc.rust-lang.org/nightly/core/ops/trait.Drop.html#tymethod.drop' class='fnname'>drop</a>(&amp;mut self)</code></h4>
</div></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <aside id="help" class="hidden">
        <div>
            <h1 class="hidden">Help</h1>

            <div class="shortcuts">
                <h2>Keyboard Shortcuts</h2>

                <dl>
                    <dt>?</dt>
                    <dd>Show this help dialog</dd>
                    <dt>S</dt>
                    <dd>Focus the search field</dd>
                    <dt>&larrb;</dt>
                    <dd>Move up in search results</dd>
                    <dt>&rarrb;</dt>
                    <dd>Move down in search results</dd>
                    <dt>&#9166;</dt>
                    <dd>Go to active search result</dd>
                </dl>
            </div>

            <div class="infos">
                <h2>Search Tricks</h2>

                <p>
                    Prefix searches with a type followed by a colon (e.g.
                    <code>fn:</code>) to restrict the search to a given type.
                </p>

                <p>
                    Accepted types are: <code>fn</code>, <code>mod</code>,
                    <code>struct</code>, <code>enum</code>,
                    <code>trait</code>, <code>type</code>, <code>macro</code>,
                    and <code>const</code>.
                </p>

                <p>
                    Search functions by type signature (e.g.
                    <code>vec -> usize</code> or <code>* -> vec</code>)
                </p>
            </div>
        </div>
    </aside>

    

    <script>
        window.rootPath = "../";
        window.currentCrate = "lldb";
        window.playgroundUrl = "";
    </script>
    <script src="../jquery.js"></script>
    <script src="../main.js"></script>
    
    <script defer src="../search-index.js"></script>
</body>
</html>